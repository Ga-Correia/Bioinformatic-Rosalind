# -*- coding: utf-8 -*-
"""atv20_Hierarchical Clustering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12IXOPTauO9K6ZQF_AKmBL7HUdVrGgKQj
"""

# k principal = cluster principal sendo c1 e c2 ou mini_key ou mini_key_value
# k secundaria = a key que tem o valor minimo do dict referenciado pela k principal

fl = open("rosalind_ba8e.txt", "r")
lines =  fl.readlines()
n_len_matrix = int(lines.pop(0))
distances_matrix = {}
list_clusters = []

def create_cluster(c1, c2):
  #print(c1, c2)
  #print(len(c1), len(c2))
  cluster_new = c1 + c2
  c_new = {}
  c_new[cluster_new] = {} # Cluster novo

  for key in list_clusters:
    # condicionais para deletar o valor minimo e sua k secundaria do k principal do dict(c1 or c2)
    if key == c1:
      del(distances_matrix[c2][key])
    elif key == c2:
      del(distances_matrix[c1][key])
    # Se k secundária não possui o valor minimo realiza a formula UPGMA e constroi Cluster novo
    else:
      val = ((distances_matrix[c1][key]*len(c1)) + (distances_matrix[c2][key]*len(c2)))/(len(c1)+len(c2))
      c_new[cluster_new][key] = val
      # Atualizo todos os clusters com o valores atuais de c1 e c2
      del(distances_matrix[key][c1])
      del(distances_matrix[key][c2])
      distances_matrix[key][cluster_new] = val


  del(distances_matrix[c1]) #deleta k1 e k2 principal para o merge das duas k
  del(distances_matrix[c2])
  distances_matrix.update(c_new) # anexa o dict c_new na matriz de distancias
  list_clusters.remove(c1)
  list_clusters.remove(c2)
  list_clusters.insert((c1[0]-1), cluster_new)

  for i in cluster_new:
    print(i, end= " ")
  print()

# Montagem da matriz de distancia por dict
for i in range(0, n_len_matrix):
  distances_matrix[tuple([i+1])] = {}
  data = (list(map(float, lines[i].split())))
  for j in range(0, n_len_matrix):
    distances_matrix[tuple([i+1])][tuple([j+1])] = data[j]

for k, v in distances_matrix.items():
  del(distances_matrix[k][k]) # tirei todos os zeros da diagonal
  list_clusters.append(k)

#print(list_clusters)

while (len(distances_matrix) > 1):
  mini_key = None # Cluster ou key principal onde está o menor valor da
  mini_key_value = None # valor da key do dict atribuido ao mini_key
  for k in list_clusters:
    mini =  min(distances_matrix[k], key=distances_matrix[k].get) # buscando a k com valor mini em cada dict dos Cluster
    if (mini_key is None and mini_key_value is None) or distances_matrix[k][mini] < distances_matrix[mini_key][mini_key_value]:
      mini_key = k
      mini_key_value = mini
  create_cluster(mini_key, mini_key_value)